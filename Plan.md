# План дизайна библиотеки

## Essentials of metaheuristics

[Ссылка на краткий конспект](Essentials of metaheuristics.md)

## Желаемые фичи

Локальные алгоритмы: дифференцировать можно автоматически, можно отдать пользователю

Реализовать классические эволюционные алгоритмы, сделать, чтобы пользователь мог также красиво и просто реализовать свои

Качественная комбинация алгоритмов друг с другом, все возможные варианты, особенно — локальных алгоритмов с глобальными, в этом случае важно уметь останавливаться. В документации — метафора про то, что умный человек лучше ориентируется в темноте, если у него есть  лучик света или на худой конец — палка, которая помогает человеку не блуждать лишний раз, хотя палка/фотоны более примитивные, но зато быстрые.

Умение работать со сложными ограничениями. Несколько способов: если можно задать плавно, можно потихоньку учеличивать его влияние на функцию ошибки. Если нет, то (не так потихоньку, а умножая булевы величины на число?)

Фреймворк для к*о*мплексного тестирования алгоритмов оптимизации

Разные форматы генома (как минимум - гомогенный и гетрогенный векторы и кастомный)

Типичные типы мутаций/кроссовера из коробки, поддержка любых пользовательских

Поддержка пересчёта функции ошибки при малых изменениях (как при малом количестве параметров, так и при малых изменениях многих)

Инструменты для разного наказания за близость особей

Мощный менеджер "питомник", "выращивающий" геномы. Заботится, чтобы много раз одного не считали и могли эффективно пересчитывать. 

Поддержка адаптивности исходя из времени, отведённого на выполнение и скорости подсчёта функции ошибки

Символьная математика?

Коэволюция

Эволюция, основанная на статистических/ML моделей. 

Негладкая оптимизация (классические методы и задачи)

## Кодовые сущности

#### Целевая функция

Пересчёт, причём с учётом генерации функции ошибки из фитнесса или наоборот. Генерация может

ФО: [0, +inf] 

#### Питомник геномов

Отвечает за контроль за пересчётом целевой функции.

Возможно, переносит, 

### Подсчитыватели статистики

Скорее всего, являются внешними по отношению к питомнику. Они должны смотреть на питомник и дедать выводы. Кто-то вызывает их при каждом случае изменения чего-то в питомнике (изменения бывают разных типов).

Вариант реализации — есть трейт «питомник» (```Nursery```) и просто базовый питомник. А можно сделать свой тип питомника (вероятно, за это ответственен конкретный алгоритм оптимизации). Этот тип будет хранить список подсчётчиков статичтики и будет реализовывать какой-то трейт (```NurseryHolder```).

#### Селекторы

#### Различные способы проведения селекции

#### Мутаторы

#### Кроссоверы

#### Геномы

#### Оптимизаторы

Каждый реализует конкретный алгоритм, использую удобную инфраструктуру библиотеки. Классические и авторские алгоритмы реализованы в библиотеке, однако пользователь должен иметь возможность испольщзовать.

Вероятно, при должны где-то быть какие-нибудь «algorithm traits» — информация о локальности/глобалности алгоритма.

При конфигурировании алгоритма должны быть разделены возможности указывать какие-то параметры напрямую или просить адаптивности (возможно, тоже  с какими-то параметрами). Желательно, чтобы можно было валидировать, что не указано и то, и другое одновременно, в compile-time.

Важно, чтобы можно было красиво комбинировать алгоритмы разными способами, в том числе — через указание дерева каким-нибудь json-ом или yaml-ом и в идеале — иметь какой-то редактор……… При комбинации алгоритмов библиотека должна знать о том, что она происходит и учитывать это, например, а подсчёте времени или логгировании.

#### Критерии остановки

Есть много способов, как опрелделить момент, в который нужно остановиться. Типичные (параметризуемые) реализованы в библиоте, но пользователь должен мочь без проблем реализовать свои. Более того, должны быть типичные комбинаторы для критерией остановки. Например, `and`, `or`, `conut_triggered > p`…

### Трейты

- 



## Собственно, алгоритмы

### Градиентный спуск



### Генетический алгоритм

Пользователь сам указывает, какие мутаторы, кроссоверы и т.д. использовать