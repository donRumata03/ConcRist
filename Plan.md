# План дизайна библиотеки

## Essentials of metaheuristics

[Ссылка на краткий конспект этой кинги](Essentials of metaheuristics.md)

## Желаемые фичи

Локальные алгоритмы: дифференцировать можно автоматически, можно отдать пользователю

Реализовать классические эволюционные алгоритмы, сделать, чтобы пользователь мог также красиво и просто реализовать свои

Качественная комбинация алгоритмов друг с другом, все возможные варианты, особенно — локальных алгоритмов с глобальными, в этом случае важно уметь останавливаться. В документации — метафора про то, что умный человек лучше ориентируется в темноте, если у него есть  лучик света или на худой конец — палка, которая помогает человеку не блуждать лишний раз, хотя палка/фотоны более примитивные, но зато быстрые.

Умение работать со сложными ограничениями. Несколько способов: если можно задать плавно, можно потихоньку учеличивать его влияние на функцию ошибки. Если нет, то (не так потихоньку, а умножая булевы величины на число?)

Фреймворк для к*о*мплексного тестирования алгоритмов оптимизации

Разные форматы генома (как минимум - гомогенный и гетрогенный векторы и кастомный)

Типичные типы мутаций/кроссовера из коробки, поддержка любых пользовательских

Поддержка пересчёта функции ошибки при малых изменениях (как при малом количестве параметров, так и при малых изменениях многих)

Инструменты для разного наказания за близость особей

Мощный менеджер "питомник", "выращивающий" геномы. Заботится, чтобы много раз одного не считали и могли эффективно пересчитывать. 

Поддержка адаптивности исходя из времени, отведённого на выполнение и скорости подсчёта функции ошибки

Символьная математика?

Коэволюция

Эволюция, основанная на статистических/ML моделей. 

Негладкая оптимизация (классические методы и задачи)

## Кодовые сущности

#### Целевая функция

Пересчёт, причём с учётом генерации функции ошибки из фитнесса или наоборот. Генерация может

ФО: [0, +inf] 

Можно сделать трейт целевая функция, а также несколько трейтов для разных дополнительных её особенностей (возможно, добавить возможность решать это в runtime…).
При каждом запуске в заданном месте кода используется свой тип TargetFunction (struct/enum/…). И реализуются трейты. 
Вероятно, можно запросить реализовать трейт дифференцируемости через экспериментальный подсчёт производной (однако хотелось бы в таком случае сохранить информацию о том, что он экспериментальный $\Rightarrow$ не очень надёжный). Можно при реализации этого трейта потребовать указать ожидаемую точность, например.



Всё это хорошо, пока не рассматривается быстрый пересчёт. Для него хотелось бы иметь свою фитнесс-фукнцию для каждого генома. Можно, конечно, делать трейт на тип, который должен уметь инстанциироваться от генома, но тогда как пользователь укажет рантайм настройки.

Нужно также предусмотреть, чтобы функция могла решить, как она будет реализовывать параллелизм. Может быть что-то асинхронное с IO, может быть -- многопоточность, может быть, видеокарта. Тогда должна быть одна общая фитнесс-функция? Но тогда так себе будет пересчитывать.

В каких случаях может быть вызов к ней? 

- Добавляется совсем новый геном (кроссовер или рандом или ещё что-то). Здесь нет никакого пересчёта.
- Происходит мутация. Здесь может быть пересчёт.

Причём добавления могут быть по одному, понемногу или помногу. И от этого хависят возможности параллелизации. ГА, например, может дать сразу много геномов на обсчёт. А отжиг - только по одному.

Алгоритм должен выделять возможности для параллелизации, то есть, если можно подсчитать сразу несколько, он должен это делать.

Вопрос: как работает Rayon, если он используется в разных библиотеках одного крейта?

Ответ: нормально: https://github.com/rayon-rs/rayon/issues/174

#### Питомник геномов

Отвечает за контроль за пересчётом целевой функции.

Возможно, переносит, 

Реализует трейт ```Nursery```, умеющий обрабатывать запросы создания новой популяции (замены старой), замены части.

Должен пересчитывать ФО, а не считать её заново, если это возможно.

#### Наблюдатели / Подсчитыватели статистики

Скорее всего, являются внешними по отношению к питомнику. Они должны смотреть на питомник и дедать выводы. Кто-то вызывает их при каждом случае изменения чего-то в питомнике (изменения бывают разных типов). Соответственно, статистики реализуют какой-то трейт.

Есть некие `[Poulation/Evoultion]Observers` - как раз те, кого оповещают об изменениях популяции. Ими могут быть статистики, логгеры и т.д.

Вариант реализации — есть трейт «питомник» (```Nursery```) и просто базовый питомник. 
А можно сделать свой тип питомника (вероятно, за это ответственен конкретный алгоритм оптимизации). 
Этот тип будет хранить список подсчётчиков статичтики и будет реализовывать какой-то трейт  (```NurseryHolder```). Типы, реализующие его, автоматом реализуют ```Nursery``` через внутренний питомник, но кроме этого при любом изменении вызывает каждый статистиков (вектор статистиков предоставляется при реализации ```NurseryHolder```-а конкретным типом).
А алгоритм может свободно использовать данные, подсчитанные статистиками через доступ к конкретным полям. 
Можно сделать процедурный макрос для автоматической реализации трейта ```NurseryHolder``` исходя из полей класса (этот трейт, конечно, ещё требует умения предоставлять mutable reference на поле ```Nursery```).

Хотелось бы также, чтобы подсчитыватели статистики умели строить какие-нибудь графики, в том числе — в реальном времени. 
Возникает вопрос — что делать, если пользователю по какой-то причине (хотя бы для построения графиков) захотелось получать какую-то статистику, которая не используется алгоритмом? Нужно предусмотреть этот случай. Тогда пользователь сам создаёт  `NurseryHolder`? Сомнительно…



Зачем могут быть полезны? Например, имеет смысл

Вопрос: почему 

#### Геномы

В общем случае библиотека может не знать о внутреннем сторении генома (главное, чтобы выбранные генетические операторы правильно с ним работали). Однако для популярных форматов геномов будут реализованы типичные операторы.

Первая категория - вектор размера

Размер может быть постоянным или нет, а также .  

#### Селекторы

Различные способы проведения селекции, вопрос, как сделать унифицированный интерфейс…

Вероятно, трейты `Tournament`, `JustSelection`… Посмотреть в genEvo и, возможно, в той Java библиотеке [ECJ](https://cs.gmu.edu/~eclab/projects/ecj/).

#### Мутаторы

#### Кроссоверы

Кроссовер (также известен как рекомбинация) принимает несколько (обычно -- две) особей и возвращает несколько особей (обычно -- одну или две). Преполагается, что потомку передадутся лучшие черты родителей. После этого может быть полезен локальный поиск, если существует эффективнавя его версия.

Можно при большом желании 

- Алгоритмы используют кроссовер внутри себя
- Поддержка произвольного (semantic) кроссовера от пользователя
- Для геномов, репрезентирующих себя как что-то часто встречающееся, реалиованы типичные штуки



#### Оптимизаторы

Каждый реализует конкретный алгоритм, использую удобную инфраструктуру библиотеки. Классические и авторские алгоритмы реализованы в библиотеке, однако пользователь должен иметь возможность использовать.

Вероятно, при должны где-то быть какие-нибудь «algorithm traits» — информация о локальности/глобалности алгоритма. Например, это далется через `trait Algorithm`. Алгоритм должен уметь делать итерации, сообщать о своём прогрессе. Вероятно, следует добавить Wrapper-ы, умеющие, например, в качестве лучшего значения возвращать лучшее значение из тех, что выдавал алгоритм (но тогда непонятно, как делать так, чтобы ).

При конфигурировании алгоритма должны быть разделены возможности указывать какие-то параметры напрямую или просить адаптивности (возможно, тоже  с какими-то параметрами). Желательно, чтобы можно было валидировать, что не указано и то, и другое одновременно, в compile-time.

Алгоритмы должны классифицироваться на локальные/глобальные, внтури глобальных — на single-state/population-based, и это надо как-то пометить внутри кода.

Все алгоритмы должны иметь какой-от общий интерфейс..........

Возможно - интерфейс для "деланья итерации", тогда алгоритм должен указывать, сколько за итерацию 

Кажется, у всех эволюционных алгоритмов есть такая штука, как итерация.

Даже у не-эвлюционных.

#### Комбинаторы  алгоритмов

==TODO==: изучить комбинацию эволюционных методов через обмен геномами и ещё какую-то кооперацию

Важно, чтобы можно было красиво комбинировать алгоритмы разными способами, в том числе — через указание дерева каким-нибудь json-ом или yaml-ом и в идеале — иметь какой-то редактор……… 
При комбинации алгоритмов библиотека должна знать о том, что она происходит и учитывать это, например, а подсчёте времени или логгировании.

#### Критерии остановки

Есть много способов, как опрелделить момент, в который нужно остановиться. Типичные (параметризуемые) реализованы в библиоте, но пользователь должен мочь без проблем реализовать свои. Более того, должны быть типичные комбинаторы для критерией остановки. Например, `and`, `or`, `conut_triggered > p`…

### Трейты

- 



## Собственно, алгоритмы

### Линейные оптимизаторы

Используются внутри более сложных алгоритмов

### Градиентный спуск

Есть огромное количество способов, как использовать идею поиска в сторону градиента.
Любому алгоритму подобного рода нужно использовать инструменты библиотеки для подсчёта градиента (изучить способы для экспериментального подсчёта!)

Отделить

- максимально надёжный и точный метод для шлифовки конечного результата (через прочёсывание всей прямой (пусть и долго и по логарифмическому пространству))
- Максимально быстрый метод — для использование внутри глобального. Может использоваться предсказание оптимального шага с учётом предыдущего опыта (распрпделение того, насколько далеко сходили на прошлых итерациях или прошлых запусках вообще (в случае глобального алгоритма). Можно даже при запусках внутри глобального строить график зависомости длины шага от номера, синхронизировать его с информацией о предыдущих шагах при этом заупске и т.д. Простой вариант — брать из предыдущих запусков только максимальное пройденное расстояние, если отбросить $\alpha \%$. Но надо время от времени всё же делать максимально подробный поиск). Также риентированный на скорость метод может «халявить» другими способами (подумать!)

"undefined"

{[""null""]}

### Метод Ньютона

Полезен в основном для "отшлифовки" ответа. Даже для оптимизации внутри глобалного поиска он вряд ли нужен.

Более того, ему необходимо высокое качество алгоритмов. 

### Генетический алгоритм

Пользователь сам указывает, какие мутаторы, кроссоверы и т.д. использовать



### Отжиг





---

# Список необработанных идей

Дбавить задачу в оптимизационнвн алгоритмы и в робота по адаптивному приращению для вычисления производной, 

Проверить гипотезу, что на трудоёмких задачах (где всеьравно будет не идеальное решение, но мы хотим нормальное за небольшое количество итераций) лучше работает вызов локального метода в мутации, а в случае простых - лучше в функции ошибки чтобы не терять общность: мы не прыгаем из ямы в яму, а гуляем по верхам. Надо адаптироваться, что у нас есть обширные зоны, в которых абсолютно одинаковая ошибка, ведь локальный оптимум один и тот же (пытаться кэшировать?)



Проводить, например, эксперимент по сравнению значения производной от приращения и портом выбора приращения, возможно, автоматичемки



Прочитать про team optimizr и рпзработать обобщённый интерфейс длямалгоритмов оптимизации



Попробовать сделать поддержку идей и еонцепций, зачастую использующихся при оптимизации, сделать их composable



Поддержка определения, что функция сколь угодно оптимизируется



Для градиентного спуска достаточно ограничить жёстко: добавить концепцию optional: недопустимости чёрного ящика в этой точке. Но сравнить, не будет ли хуже, чем наказание? Можно находить сначала не строго, а потом строго, но что делать, если в окрестности все undefined? Можно потихоньку усиливать наказание за плохие значения (нарушение ограничений),приводя их к бесконечным: сделать это обобщённо. Ограничения могут задаваться черноящечным булом, но тогда непонятно, что делать, а могут градациями. Причём если неравенство, то можно задавать градации автоматически через степень нарушение равенства, поколдовав с масштабом как самих аргументов, так и функции ошибки. Добавить обобщённый функционал для определения масштабов всего и вся , для сгенерированных функций и вообще - генерировать производные, добавить свойство функций дифференцируемость, которое можно вызывать. Генерировать это свойство и длч сгенерированных фугкций. Это для композируемости 
Применить неравенства как ограничения для матбота, добавить этот режим, как-то, чтобы было аналитически дифференцируемо



Для художника генерировать ограничения через constraining, но в градациях, дифференцируемость экспериментальная

Для остального сказальь, что можно и булевые ограничения, тогда методы упрутся в инф, границу, но лучше использовать либо генерацию снеравенствами, либо  сделать градации, посоветовать добавить дифференцируемость



Добавить для структурки оптимизируемой функции функцию дифференцирования экспериментально
as_differentiable_experimentally

Ui бота: использовать конечные автоматы,  базы данных, сайт для клнффигурации, вип режим, свой язык программирования, как парсить?!

Реализовать автовычислерие фитнесс функции из функции  ошибки через дополнительные данные о масштабах (использовать данные о популяции), та идея, что гоша говорил о функции порога, которая позволяет потихоньку улучшаться. Но как она поддержит быстрое улучшение, которые очень полезно и может иметь место в начале уж точно.
Как обобщить это не на популяцию, а вообще



Разделить библиотеку на работу со структурами данных, полезных для алгоритмов оптимизации в целом (смотреть конспект из итмо) и, собственного, алгоритмы, которые становится легко писать



Посмотреть хорошие общие книги о методах оптимизации, скачать, ищучить



Подумать, что с оптимизацией на всём пространстве, у нас только даблы, логарифмические прочёсывание, логарифмическая нмерная сетка, что делать с экспоненциальным ростом количества ячеек, сложно. Вообще найти то место, где функция задана.
Как вариант - спрашивать у пользователя не гиперкуб, а гиперточку
по разному себя вести для маломерных пространств, так как там экспоненциальный рост не сказывется



Оформить что-то вроде сектора развития, сделать мануал на основе текста для старс

Сдеать много поддерживаемых алгоритмов для однгмерноой опттмизации (обычно - внутри каждого шага)

В описании раскрыть метафору о том, почему зачастую лучше использовать вложенные в методы оптимизации локальные методы, чем делать последовательность: человек, например, может ДУМАТЬ, используя калькулятор.
Сказать, к каким последствиям может привести последовательность. Например, для многих параметров более тяжёлый алгоритм может просто блуждать, траатяя очень много ресурсов

Рассказать Гоше, что я вдохновился, спросить об оптимальной стукртуре книги, попросить фидбек

Изучить возможности и структуру, архитектуоу существующих решений

Подумать, есть ли края в художнике, на которых функция становится не дифференцируемой, добавить возможность обработки не дифференцируемой то функции в каком-то месте

Добавить поддержку большого количества ошибок

Подумать, как можно обобщить подсказки оптимизатору и реализовать библиотеку так, чтобы она поддерживала их широкий спектр

Для величин, как-то изменяющихся с прогрессом выполнения сделать обобщённый интерфейс

Сделать, наконец, дедущкину работу

Для фкгнкции поддерживать как-то производную по направлени!ю, это полезно в случае одномерного поиска лучшего шага по направлению

Инфраструктура для для бенчмарков

Нормально, что мне все хочется задавать в виде оптимизационной задачи? Деформация мышления при решении или просто выбирают таки интересные задачи, не факт что имеющие простое решение

Инфраструктура для прозрачности данных, наример, просматривать срез многомерной фкнкци при выданной прямой, например, по градиенту
Построить для типичных, в том числе пэинтер функций зависимость её от шага по градиенту

Новая концепция: всё строится от библиотеки оптимизации, есть много задач, в том числе пеинтер, он чрез реализацию интерфейсов специфиирцет задачу

Подумал, чо ещё из пэитера можно обобщить и ввести в библиотеку для оптимизации

Поискать ещё проекты из реальной жизни для тестирования, привлечь ползователей

Динамическая оптимизация(приближение хорошо известно. Из прошлого шага, изменение небольшое)

Умный динамический учёт времни вычисления функции и её производных каких-то порядков, на основе этого и выбор алгоритма, и умение планировать исходя из данного времени (последнее крайне юзабельна на практике)

Аннотации времени работы и качества сходимости для алгоритмов для динамической конфигураци

Пдсчтёт статистики по времени, выбранным алгоритмам, вычислениям функции и производных

Для глобальных алгоритмов, которые имеют разные аспекты агрессивности учитывать их изменение для конфигурации с учётом времени исполнения

Поддержка разных типов параметров для га как минимум: дискретные инты, енамы, непрерывные

Умение дискретизировать прерывнве параметры, ровериьь , даёт ли это прирост

Проверить предположение об экспонениальном времении от количества параметров

Тот тип бенчмарков с поиском количества итераций для заданного качества. Задавать степени качества работы не вручную, а по опыту многих других алгоритмов (так как это не очевидная штука), из опыта смотрим количество итераций для данного щначения , затем график качества от времени отлично описывает плгоритм, может быть втдо, что локальный

Аннотировать локальные,средние и лобальные

Автоматически вычислятть локальность и вообще степень локальности алгоритма по этим графикам, зависимость этой степени от параметров агрессивности (она общая для разных применений?)

Находить кривые Парето для параметров алгоритма алгоритма, где их хранить?

Если кривые Парето разные для разных функций, то сделать удобный интерфейс для определения их и сохранения. Полезно, если после конфигурации функций она лёгкая и используется много раз

Сделать гайдлайны для добавления новых алгоритмов (и конечно, возможность, api), сделать возможность поддержки external алгоритмом всех фишек

Что делать с гиперпараметрами? Та же кривая парето, если мало или оптимизация гиперпараметров через тоже методы оптимизации, если много?

Поддержка многопараметрической оптимизации (прохождение по жёлобу?) после просто оптимизации, делать это для многих случаев

Красивый рендеринг графиков? IDE?

Провести глобальное исследование известных алгоритмов, подтвердить выводы об их локальности глобальности. Для исследования использовать много gpu

Для разных задач проверить, какой подходит лучше, для этого просить данные у пользователей

Уметь распараллеливания вычисления на GPU? Как минимум, для известных функций (параллельность на уровне большого количества функций за раз)

Осознать, когда более эффективно работает gpu

Понять, как выделить время, откуда финансирование, в рамках чего делать?

Насчёт пересчёта: специализация для производной как минимум, так как при маленьком смещения достаточно пересчитать совсем немного значений

Прочитать про team optimizr и рпзработать обобщённый интерфейс для алгоритмов оптимизации, выделив общие их признаки

Сформулировать преимущества по сравнению с остальными решениями (первое очевидное - много обобщённых алгоритмов, возможность указывать функцию много параметров функций, то есть можно хорошо задавать функции из реальной жизни с их мета свойствами, хотя они и не аналитические)
кооперация локальных и глобальных
Поддержка быстрого пересчёта с учётом градиента

Автогенерация архитектуры сети: https://habr.com/ru/company/spbifmo/blog/558450/

Некоторые методы эвристической оптимизации: https://habr.com/ru/post/193894/

При аннотировании функций если про какие-то параметры известны какие-то свойства (линейность, унимодальность и и т.д., то об этом говорить)

непрерывная оптимизация не может быть применена, если хотя бы один параметр дискретен? Можно считать количество состояний дискретных параметров и перебирать, если мало. Иначе - комбинаторная оптимизация с возможностть локального улучшения по непрерывным параметрам

Сможет ли локальный алгоритм достаточно хорошо работать для размещения целого набора мазков (там ведь сложно может быть)? Как сделать, чтобы смог?

Сделать тесты для локальных алгоритмов, чтобы при малом смещении попадали туда же

Как же нейросети и типичные ml алгоритмы?

Тестирование на популярных задачах комбинаторной оптимизации

https://www.machinelearningmastery.ru/genetic-programming-for-ai-heuristic-optimization-9d7fdb115ee1/

В га: сравнить методов распределения популяции, выбрать лучший в зависимости от количества данных вычислений функции

Библиотечная реализация нечёткой логики

Изучить линейное и вообще математическое программирование

Использование шаблонного метапрограммирования 
при реализации параллельных эвристических алгоритмов 
оптимизации 
О.И. Булычов

Библиотека HeO

Мета эвристики

Гибридные алгоритмы

google: libraries for heuristic optimization

https://github.com/gugarosa/opytimizer

Проанализировать структуру, посмотреть на методы

Абстракция space (нужны деформации?)

Визуализация, например, сходимости

Изучить типы гибридизаций алгоритмов оптимизации

Прочитать про team optimizr и рпзработать обобщённый интерфейс длямалгоритмов оптимизации

Дбавить задачу в оптимизационнвн алгоритмы и в робота по адаптивному приращению для вычисления производной, 

Проверить гипотезу, что на трудоёмких задачах (где всеьравно будет не идеальное решение, но мы хотим нормальное за небольшое количество итераций) лучше работает вызов локального метода в мутации, а в случае простых - лучше в функции ошибки чтобы не терять общность: мы не прыгаем из ямы в яму, а гуляем по верхам. Надо адаптироваться, что у нас есть обширные зоны, в которых абсолютно одинаковая ошибка, ведь локальный оптимум один и тот же (пытаться кэшировать?)

Насчёт пересчёта: специализация для производной как минимум, так как при маленьком смещения достаточно пересчитать совсем немного значений

Как происходит работа с constraints в существующих решениях? Нприаер, HeO или https://github.com/alphaville/optimization-engine/blob/master/src/constraints/hyperplane.rs

https://gitlab.inria.fr/paradiseo/paradiseo/-/wikis/Documentation/Design%20concept

Модуль для экспериментального подсчёта градиента/липшеца и т.д.

https://www.arewelearningyet.com/metaheuristics/

https://github.com/argmin-rs/argmin

https://medium.com/blackrock-engineering/writing-an-optimization-library-in-rust-588628c0e500

Метод ветвей границ для комбинаторной оптимизации?

Попробовать комбинировать комбинаторную и непрерывную оптимизацию так: использовать дискретные (в том числе — локальные) алгоритмы каждый раз внутри алгоритма на д дискретным пространством

https://www.sciencedirect.com/science/article/abs/pii/S0098135418300164

Секция с максимально абстрактным описанием подходов и типов пормулировки конкретных задач из предметной области для передачи оптимизатору

Gray-box

Кажется, ассимптотическая скорость сходимости не так важна в случае художника, например, поэтому ньютон может быть и не нужен

MathBot: добавить возможность expand, как минимум — если участвуют просто произведения сумм, приведение подобных слагаемых

Должно быть можно указывать, какие «переменные» — переменные, а какие — не очень => группировать по переменным 
Принимать инпут в латехе

По факту «группировать» можно по подмножеству всех переменных

Протестить по этому (что группируется по x, y):

$7\sqrt{5} (cos(\alpha) x_1 - sin(\alpha) y_1)^2$ 
        $+ \sqrt{5}(sin(\alpha) x_1 + cos(\alpha) y_1)^2$ 
        $+ 8\sqrt{5}(cos(\alpha) x_1 - sin(\alpha) y_1)(sin(\alpha) x_1 + cos(\alpha) y_1)$ 
        $+ 72 (cos(\alpha) x_1 - sin(\alpha) y_1)$ 
        $+ 36 (sin(\alpha) x_1 + cos(\alpha) y_1) 27\sqrt{5}$

Todo: заставить подбиратель использовать новую библиотеку, использовать это применение для тестов в том числе

Гармонический поиск. Harmony Search / Хабр
https://habr.com/ru/post/193994/ 	

Что значит дополнительный контур га?
метод легко и удобно встраивается в другие методы (например, в меметические алгоритмы, или в качестве дополнительного контура генетического алгоритма).



Изучить существующие библиотеки на расте для оптимизации. В частности:
1. Доизучать: https://github.com/innoave/genevo
2. https://github.com/m-decoster/RsGenetic
3. https://github.com/Martin1887/oxigen
4. https://github.com/pkalivas/radiate

ПРО КАЖДЫЙ НАПИСАТЬ ФИДБЕК, ПЛЮСЫ И МИНУСЫ



Музыкальная теория с библиотекой musical-theory-rustДобавить в тесты проблем: 

https://github.com/pkalivas/radiate#example

Протестировать на задачах МЭ Дворкина по эвристической оптимизации!

Найти известные контесты и просто наборы задач для тестов

Кэшировать значения фитнесс-функции при некоторых параметрах, в идеале — вычисляемых в run-time, но, если пользователь скажет, что хочет конкретное, можно не адаптировать в run-time.

Как адаптирировать? Ну, очень просто. Зависит от соотношения длины генома (насколько долго вычислять хэш-функцию) и от вычисленной скорости вычисления ошибки. Если размер мал по сравнению со временем на вычисление, кэшировать.

Принципиально разные режимы: либо автоподстройка, либо детальное указывание, как-то выделить разделение режимов в отдельный концепт?

Логгирование: разные форматы, учитывая Data representation

visual logging (images, graphs, tempararies)

User interface for Painter

Название : что-то из heuristic optinization algorithms building blocks; continuous, discrete, combinatorial

Вариант: Concrustic или Concristic: a ballanced library: a bit of both continusous and disxrete (opt algos), a lot of heuristics, even some combinatorial and of course a certain amount of crust of rust

Учесть, что можно использовать слово meta. И ещё Post?)
Не забыть про building blocks

Создать wrapper-ы для популярных бэкэндов библиотек с моим интерфейсом в тестах, сравнить по бенчмаркам

Художник: при кроссоверах брать во внимание положение, топологически сортировать?

Не лучше ли будет работать, если, например, хранить геном в 2d и использовать это при всех с ним операциях?

Но это всё равно, что просто производить кастомные операции с геномом, учитывая расположение

Сделать красивые визуализации алгоритмов в 3d на сложных функциях

В отжиге таргетировать процент применённых мутаций (и отдельно среди худших?)

При запуске алгоритма писать в консоль развернутую информацию и его параметрах

В случае с матботом: в качестве отбора использовать только порядок, но не само значение финтесс-функции, так как могут быть очень разные значения?

Адаптировать метод отбора в зависимости от распределения функции ошибки?

ВАЖНО: ПРИ РЕКОМБИНАЦИИ В РОБОТЕ ХУДОЖНИКЕ БРАТЬ ЗОНЫ С ХОРОШЕЙ heat map из каждого родителя (может быть, даже более двух штук), А ПОТОМ ЗАПУСКАТЬ ЛОКАЛЬНЫЙ ПОИСК

Ввести меру похожести разных картинок внутри популяции. Например, MSE между ними, причём делать это между каждым мазком по отдельности в порядке, в котом они расположены?
А может быть, оптимальный парсоч?

Использовать информацию о количестве детей, имеющих лучшую приспособленность, чем родители для изменения mutation rate, правило одной пятой
Как-то назвать общий случай на английском, когда дети лучше родителей

Более общее, чем mu +/, lambda: бить тех, кто живёт слишком долго

Design goal: сделать максимально кастомизируемым, но не обязательно малословным
То есть нужно избежать такой ситуации, когда что-то вообще нельзя сделать и минимизировать количество ситуаций, в которых приходится для стандартных штук писать что-то своё, то есть делать что-либо кроме конструирования готовых блоков

Например, поддержка пересчёта в общем виде

Обобщить идею, что геном может быть разбит на блоки, которые можно переставлять, но нельзя связывать. В частности, line recombination не подходит, да и внутри одной line recombination тоже будет бредово. А вот если одни и те же параметры, будет более или менее. Хотя все ещё так себе.
То ли дело умно работать с каждым блоком по-отдельности. Например, с мазками. Важно делать при кроссовере локальную оптимизацию, иначе его не примут вообще

Геном может быть: Гомогенный вектор, гетерогенный, граф, дерево программы и т д. ...

Уметь конструировать через лямбду и мю и через последовательность действий

Решить вопрос с тем, что разные предлагают разные последовательности

CI через github actions

Селекция через рулетку: оптимизировать, генерируя сразу много рандомных чисел, их сортируя, а потом генерируя упорядоченно, проходят по рулетке вверх

Библиотека ECJ

Инфраструктура для подсчет и пересчёта ошибки, кэширование

Похожие либо выбрасывать, либо считать, что у них одинаковая ошибка

Движок для оценки variance популяции, её широты (питомник?)). Сделать, чтобы была возможность включить или отключить подсчет разных значений. Иметь дефолтгые значения для этого

В дифференциальной эволюции: контролировать diversity, разрешая разный диапазон перехода за пределы направления к выбранным точкам

В de добавлять вектор увеличения фитнеса?

Задача с роботом художником настолько сложная, но настолько хорошо адаптируемая, что CMA-ES, который мало что о ней знает, может быть хуже наших алгоритмов

Для динамической подстройки гиперпараметров пользователь может представить набор эвристик. Каждая — какая-то  функция, которая, по заверениям пользователя, для хорошей эволюции должна быть, например, константой, причём она (по заверениям пользователя) положительно или отрицательно коррелирует с какими-то гиперпараметрами. Тогда, чтобы поддерживать эту величину на постоянном уровне, можно использовать какой-нибудь регулятор.
Пример величины: процент принимаемости новых геномов в отжиге. Ожидается, что он будет на заданном уровне (например, ≈1/5). Понятно, что чем больше температура, тем больше принимаемость.
Посмотреть, что насчёт этого думают ParadiseO.

