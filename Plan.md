# План дизайна библиотеки

## Essentials of metaheuristics

[Ссылка на краткий конспект этой кинги](Essentials of metaheuristics.md)

## Желаемые фичи

Локальные алгоритмы: дифференцировать можно автоматически, можно отдать пользователю

Реализовать классические эволюционные алгоритмы, сделать, чтобы пользователь мог также красиво и просто реализовать свои

Качественная комбинация алгоритмов друг с другом, все возможные варианты, особенно — локальных алгоритмов с глобальными, в этом случае важно уметь останавливаться. В документации — метафора про то, что умный человек лучше ориентируется в темноте, если у него есть  лучик света или на худой конец — палка, которая помогает человеку не блуждать лишний раз, хотя палка/фотоны более примитивные, но зато быстрые.

Умение работать со сложными ограничениями. Несколько способов: если можно задать плавно, можно потихоньку учеличивать его влияние на функцию ошибки. Если нет, то (не так потихоньку, а умножая булевы величины на число?)

Фреймворк для к*о*мплексного тестирования алгоритмов оптимизации

Разные форматы генома (как минимум - гомогенный и гетрогенный векторы и кастомный)

Типичные типы мутаций/кроссовера из коробки, поддержка любых пользовательских

Поддержка пересчёта функции ошибки при малых изменениях (как при малом количестве параметров, так и при малых изменениях многих)

Инструменты для разного наказания за близость особей

Мощный менеджер "питомник", "выращивающий" геномы. Заботится, чтобы много раз одного не считали и могли эффективно пересчитывать. 

Поддержка адаптивности исходя из времени, отведённого на выполнение и скорости подсчёта функции ошибки

Символьная математика?

Коэволюция

Эволюция, основанная на статистических/ML моделей. 

Негладкая оптимизация (классические методы и задачи)

## Кодовые сущности

#### Целевая функция

Пересчёт, причём с учётом генерации функции ошибки из фитнесса или наоборот. Генерация может

ФО: [0, +inf] 

Можно сделать трейт целевая функция, а также несколько трейтов для разных дополнительных её особенностей (возможно, добавить возможность решать это в runtime…).
При каждом запуске в заданном месте кода используется свой тип TargetFunction (struct/enum/…). И реализуются трейты. 
Вероятно, можно запросить реализовать трейт дифференцируемости через экспериментальный подсчёт производной (однако хотелось бы в таком случае сохранить информацию о том, что он экспериментальный $\Rightarrow$ не очень надёжный). Можно при реализации этого трейта потребовать указать ожидаемую точность, например.



Всё это хорошо, пока не рассматривается быстрый пересчёт. Для него хотелось бы иметь свою фитнесс-фукнцию для каждого генома. Можно, конечно, делать трейт на тип, который должен уметь инстанциироваться от генома, но тогда как пользователь укажет рантайм настройки.

Нужно также предусмотреть, чтобы функция могла решить, как она будет реализовывать параллелизм. Может быть что-то асинхронное с IO, может быть -- многопоточность, может быть, видеокарта. Тогда должна быть одна общая фитнесс-функция? Но тогда так себе будет пересчитывать.

В каких случаях может быть вызов к ней? 

- Добавляется совсем новый геном (кроссовер или рандом или ещё что-то). Здесь нет никакого пересчёта.
- Происходит мутация. Здесь может быть пересчёт.

Причём добавления могут быть по одному, понемногу или помногу. И от этого хависят возможности параллелизации. ГА, например, может дать сразу много геномов на обсчёт. А отжиг - только по одному.

Алгоритм должен выделять возможности для параллелизации, то есть, если можно подсчитать сразу несколько, он должен это делать.

Вопрос: как работает Rayon, если он используется в разных библиотеках одного крейта?

Ответ: нормально: https://github.com/rayon-rs/rayon/issues/174

#### Питомник геномов

Отвечает за контроль за пересчётом целевой функции.

Возможно, переносит, 

Реализует трейт ```Nursery```, умеющий обрабатывать запросы создания новой популяции (замены старой), замены части.

Должен пересчитывать ФО, а не считать её заново, если это возможно.

#### Подсчитыватели статистики

Скорее всего, являются внешними по отношению к питомнику. Они должны смотреть на питомник и дедать выводы. Кто-то вызывает их при каждом случае изменения чего-то в питомнике (изменения бывают разных типов). Соответственно, статистики реализуют какой-то трейт.

Вариант реализации — есть трейт «питомник» (```Nursery```) и просто базовый питомник. 
А можно сделать свой тип питомника (вероятно, за это ответственен конкретный алгоритм оптимизации). 
Этот тип будет хранить список подсчётчиков статичтики и будет реализовывать какой-то трейт  (```NurseryHolder```). Типы, реализующие его, автоматом реализуют ```Nursery``` через внутренний питомник, но кроме этого при любом изменении вызывает каждый статистиков (вектор статистиков предоставляется при реализации ```NurseryHolder```-а конкретным типом).
А алгоритм может свободно использовать данные, подсчитанные статистиками через доступ к конкретным полям. 
Можно сделать процедурный макрос для автоматической реализации трейта ```NurseryHolder``` исходя из полей класса (этот трейт, конечно, ещё требует умения предоставлять mutable reference на поле ```Nursery```).

Хотелось бы также, чтобы подсчитыватели статистики умели строить какие-нибудь графики, в том числе — в реальном времени. 
Возникает вопрос — что делать, если пользователю по какой-то причине (хотя бы для построения графиков) захотелось получать какую-то статистику, которая не используется алгоритмом? Нужно предусмотреть этот случай. Тогда пользователь сам создаёт  `NurseryHolder`? Сомнительно…



Зачем могут быть полезны? Например, имеет смысл

Вопрос: почему 

#### Геномы

В общем случае библиотека может не знать о внутреннем сторении генома (главное, чтобы выбранные генетические операторы правильно с ним работали). Однако для популярных форматов геномов будут реализованы типичные операторы.

Первая категория - вектор размера

Размер может быть постоянным или нет, а также .  

#### Селекторы

Различные способы проведения селекции, вопрос, как сделать унифицированный интерфейс…

Вероятно, трейты `Tournament`, `JustSelection`… Посмотреть в genEvo и, возможно, в той Java библиотеке [ECJ](https://cs.gmu.edu/~eclab/projects/ecj/).

#### Мутаторы

#### Кроссоверы

Кроссовер (также известен как рекомбинация) принимает несколько (обычно -- две) особей и возвращает несколько особей (обычно -- одну или две). Преполагается, что потомку передадутся лучшие черты родителей. После этого может быть полезен локальный поиск, если существует эффективнавя его версия.

Можно при большом желании 

- Алгоритмы используют кроссовер внутри себя
- Поддержка произвольного (semantic) кроссовера от пользователя
- Для геномов, репрезентирующих себя как что-то часто встречающееся, реалиованы типичные штуки



#### Оптимизаторы

Каждый реализует конкретный алгоритм, использую удобную инфраструктуру библиотеки. Классические и авторские алгоритмы реализованы в библиотеке, однако пользователь должен иметь возможность использовать.

Вероятно, при должны где-то быть какие-нибудь «algorithm traits» — информация о локальности/глобалности алгоритма. Например, это далется через `trait Algorithm`. Алгоритм должен уметь делать итерации, сообщать о своём прогрессе. Вероятно, следует добавить Wrapper-ы, умеющие, например, в качестве лучшего значения возвращать лучшее значение из тех, что выдавал алгоритм (но тогда непонятно, как делать так, чтобы ).

При конфигурировании алгоритма должны быть разделены возможности указывать какие-то параметры напрямую или просить адаптивности (возможно, тоже  с какими-то параметрами). Желательно, чтобы можно было валидировать, что не указано и то, и другое одновременно, в compile-time.

Алгоритмы должны классифицироваться на локальные/глобальные, внтури глобальных — на single-state/population-based, и это надо как-то пометить внутри кода.

Все алгоритмы должны иметь какой-от общий интерфейс..........

Возможно - интерфейс для "деланья итерации", тогда алгоритм должен указывать, сколько за итерацию 

Кажется, у всех эволюционных алгоритмов есть такая штука, как итерация.

Даже у не-эвлюционных.

#### Комбинаторы  алгоритмов

==TODO==: изучить комбинацию эволюционных методов через обмен геномами и ещё какую-то кооперацию

Важно, чтобы можно было красиво комбинировать алгоритмы разными способами, в том числе — через указание дерева каким-нибудь json-ом или yaml-ом и в идеале — иметь какой-то редактор……… 
При комбинации алгоритмов библиотека должна знать о том, что она происходит и учитывать это, например, а подсчёте времени или логгировании.

#### Критерии остановки

Есть много способов, как опрелделить момент, в который нужно остановиться. Типичные (параметризуемые) реализованы в библиоте, но пользователь должен мочь без проблем реализовать свои. Более того, должны быть типичные комбинаторы для критерией остановки. Например, `and`, `or`, `conut_triggered > p`…

### Трейты

- 



## Собственно, алгоритмы

### Линейные оптимизаторы

Используются внутри более сложных алгоритмов

### Градиентный спуск

Есть огромное количество способов, как использовать идею поиска в сторону градиента.
Любому алгоритму подобного рода нужно использовать инструменты библиотеки для подсчёта градиента (изучить способы для экспериментального подсчёта!)

Отделить

- максимально надёжный и точный метод для шлифовки конечного результата (через прочёсывание всей прямой (пусть и долго и по логарифмическому пространству))
- Максимально быстрый метод — для использование внутри глобального. Может использоваться предсказание оптимального шага с учётом предыдущего опыта (распрпделение того, насколько далеко сходили на прошлых итерациях или прошлых запусках вообще (в случае глобального алгоритма). Можно даже при запусках внутри глобального строить график зависомости длины шага от номера, синхронизировать его с информацией о предыдущих шагах при этом заупске и т.д. Простой вариант — брать из предыдущих запусков только максимальное пройденное расстояние, если отбросить $\alpha \%$. Но надо время от времени всё же делать максимально подробный поиск). Также риентированный на скорость метод может «халявить» другими способами (подумать!)

"undefined"

{[""null""]}

### Метод Ньютона

Полезен в основном для "отшлифовки" ответа. Даже для оптимизации внутри глобалного поиска он вряд ли нужен.

Более того, ему необходимо высокое качество алгоритмов. 

### Генетический алгоритм

Пользователь сам указывает, какие мутаторы, кроссоверы и т.д. использовать



### Отжиг

