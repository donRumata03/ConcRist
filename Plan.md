# План дизайна библиотеки

## Essentials of metaheuristics

[Ссылка на краткий конспект этой кинги](Essentials of metaheuristics.md)

## Желаемые фичи

Локальные алгоритмы: дифференцировать можно автоматически, можно отдать пользователю

Реализовать классические эволюционные алгоритмы, сделать, чтобы пользователь мог также красиво и просто реализовать свои

Качественная комбинация алгоритмов друг с другом, все возможные варианты, особенно — локальных алгоритмов с глобальными, в этом случае важно уметь останавливаться. В документации — метафора про то, что умный человек лучше ориентируется в темноте, если у него есть  лучик света или на худой конец — палка, которая помогает человеку не блуждать лишний раз, хотя палка/фотоны более примитивные, но зато быстрые.

Умение работать со сложными ограничениями. Несколько способов: если можно задать плавно, можно потихоньку учеличивать его влияние на функцию ошибки. Если нет, то (не так потихоньку, а умножая булевы величины на число?)

Фреймворк для к*о*мплексного тестирования алгоритмов оптимизации

Разные форматы генома (как минимум - гомогенный и гетрогенный векторы и кастомный)

Типичные типы мутаций/кроссовера из коробки, поддержка любых пользовательских

Поддержка пересчёта функции ошибки при малых изменениях (как при малом количестве параметров, так и при малых изменениях многих)

Инструменты для разного наказания за близость особей

Мощный менеджер "питомник", "выращивающий" геномы. Заботится, чтобы много раз одного не считали и могли эффективно пересчитывать. 

Поддержка адаптивности исходя из времени, отведённого на выполнение и скорости подсчёта функции ошибки

Символьная математика?

Коэволюция

Эволюция, основанная на статистических/ML моделей. 

Негладкая оптимизация (классические методы и задачи)

## Кодовые сущности

#### Целевая функция

Пересчёт, причём с учётом генерации функции ошибки из фитнесса или наоборот. Генерация может

ФО: [0, +inf] 

Можно сделать трейт целевая функция, а также несколько трейтов для разных дополнительных её особенностей (возможно, добавить возможность решать это в runtime…).
При каждом запуске в заданном месте кода используется свой тип TF (struct/enum/…). И реализуются трейты. 
Вероятно, можно запросить реализовать трейт дифференцируемости через экспериментальный подсчёт производной (однако хотелось бы в таком случае сохранить информацию о том, что он экспериментальный $\Rightarrow$ не очень надёжный). Можно при реализации этого трейта потребовать указать ожидаемую точность, например.

#### Питомник геномов

Отвечает за контроль за пересчётом целевой функции.

Возможно, переносит, 

Реализует трейт ```Nursery```, умеющий обрабатывать запросы создания новой популяции (замены старой), замены части.

Должен пересчитывать ФО, а не считать её заново, если это возможно.

### Подсчитыватели статистики

Скорее всего, являются внешними по отношению к питомнику. Они должны смотреть на питомник и дедать выводы. Кто-то вызывает их при каждом случае изменения чего-то в питомнике (изменения бывают разных типов). Соответственно, статистики реализуют какой-то трейт.

Вариант реализации — есть трейт «питомник» (```Nursery```) и просто базовый питомник. 
А можно сделать свой тип питомника (вероятно, за это ответственен конкретный алгоритм оптимизации). 
Этот тип будет хранить список подсчётчиков статичтики и будет реализовывать какой-то трейт  (```NurseryHolder```). Типы, реализующие его, автоматом реализуют ```Nursery``` через внутренний питомник, но кроме этого при любом изменении вызывает каждый статистиков (вектор статистиков предоставляется при реализации ```NurseryHolder```-а конкретным типом).
А алгоритм может свободно использовать данные, подсчитанные статистиками через доступ к конкретным полям. 
Можно сделать процедурный макрос для автоматической реализации трейта ```NurseryHolder``` исходя из полей класса (этот трейт, конечно, ещё требует умения предоставлять mutable reference на поле ```Nursery```).

Хотелось бы также, чтобы подсчитыватели статистики умели строить какие-нибудь графики, в том числе — в реальном времени. 
Возникает вопрос — что делать, если пользователю по какой-то причине (хотя бы для построения графиков) захотелось получать какую-то статистику, которая не используется алгоритмом? Нужно предусмотреть этот случай. Тогда пользователь сам создаёт  `NurseryHolder`? Сомнительно…

#### Селекторы

Различные способы проведения селекции, вопрос, как сделать унифицированный интерфейс…

Вероятно, трейты `Tournament`, `JustSelection`… Посмотреть в genEvo и, возможно, в той Java библиотеке [ECJ](https://cs.gmu.edu/~eclab/projects/ecj/).

#### Мутаторы

#### Кроссоверы

#### Геномы

#### Оптимизаторы

Каждый реализует конкретный алгоритм, использую удобную инфраструктуру библиотеки. Классические и авторские алгоритмы реализованы в библиотеке, однако пользователь должен иметь возможность использовать.

Вероятно, при должны где-то быть какие-нибудь «algorithm traits» — информация о локальности/глобалности алгоритма. Например, это далется через `trait Algorithm`. Алгоритм должен уметь делать итерации, сообщать о своём прогрессе. Вероятно, следует добавить Wrapper-ы, умеющие, например, в качестве лучшего значения возвращать лучшее значение из тех, что выдавал алгоритм (но тогда непонятно, как делать так, чтобы ).

При конфигурировании алгоритма должны быть разделены возможности указывать какие-то параметры напрямую или просить адаптивности (возможно, тоже  с какими-то параметрами). Желательно, чтобы можно было валидировать, что не указано и то, и другое одновременно, в compile-time.

Алгоритмы должны классифицироваться на локальные/глобальные, внтури глобальных — на single-state/population-based



#### Комбинаторы  алгоритмов

==TODO==: изучить комбинацию эволюционных методов через обмен геномами и ещё какую-то кооперацию

Важно, чтобы можно было красиво комбинировать алгоритмы разными способами, в том числе — через указание дерева каким-нибудь json-ом или yaml-ом и в идеале — иметь какой-то редактор……… 
При комбинации алгоритмов библиотека должна знать о том, что она происходит и учитывать это, например, а подсчёте времени или логгировании.

#### Критерии остановки

Есть много способов, как опрелделить момент, в который нужно остановиться. Типичные (параметризуемые) реализованы в библиоте, но пользователь должен мочь без проблем реализовать свои. Более того, должны быть типичные комбинаторы для критерией остановки. Например, `and`, `or`, `conut_triggered > p`…

### Трейты

- 



## Собственно, алгоритмы

### Линейные оптимизаторы

Используются внутри более сложных алгоритмов

### Градиентный спуск

Есть огромное количество способов, как использовать идею поиска в сторону градиента.
Любому алгоритму подобного рода нужно использовать инструменты библиотеки для подсчёта градиента (изучить способы для экспериментального подсчёта!)

Отделить

- максимально надёжный и точный метод для шлифовки конечного результата (через прочёсывание всей прямой (пусть и долго и по логарифмическому пространству))
- Максимально быстрый метод — для использование внутри глобального. Может использоваться предсказание оптимального шага с учётом предыдущего опыта (распрпделение того, насколько далеко сходили на прошлых итерациях или прошлых запусках вообще (в случае глобального алгоритма). Можно даже при запусках внутри глобального строить график зависомости длины шага от номера, синхронизировать его с информацией о предыдущих шагах при этом заупске и т.д. Простой вариант — брать из предыдущих запусков только максимальное пройденное расстояние, если отбросить $\alpha \%$. Но надо время от времени всё же делать максимально подробный поиск). Также риентированный на скорость метод может «халявить» другими способами (подумать!)

### Генетический алгоритм

Пользователь сам указывает, какие мутаторы, кроссоверы и т.д. использовать